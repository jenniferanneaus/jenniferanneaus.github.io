---
layout: post
current: post
cover:  assets/images/covers/squares.jpg
navigation: True
title: Sum of Squares
date: 2019-09-21 10:15:00
tags: [python, maths]
class: post-template
subclass: 'post tag-python tag-maths'
---
Today I was working on Sum of Squares, one of the problems on [Project Euler](https://projecteuler.net). This problem is quite maths-heavy, and led me to research a few concepts such as Fermat's $4n+1$ Theorem and the Sum of Squares Function. The code itself, written in Python, utilised recursive functions to find an efficient solution.

[The problem](https://projecteuler.net/problem=273) states the following:

> Consider equations of the form: $a^2 + b^2 = N$, $0 \leq a \leq b$, $a$, $b$ and $N$ integer.
>
> For $N$=65 there are two solutions:
>
> $a$=1, $b$=8 and $a$=4, $b$=7.
>
> We call $S(N)$ the sum of the values of $a$ of all solutions of $a^2 + b^2 = N$, $0 \leq a \leq b$, $a$, $b$ and $N$ integer.
>
> Thus $S(65)$ = 1 + 4 = 5.
>
> Find $\sum S(N)$, for all squarefree $N$ only divisible by primes of the form 4$k$+1 with 4$k$+1 < 150.

Decomposing this problem into its component parts, there are a few things we need:

1. All primes of the form 4$k$+1, with 4$k$+1<150.
2. A way to find all squarefree $N$ that are only divisible by these primes.
3. An efficient way to calculate $S(N)$ for each of the squarefree $N$.

We begin with step 1. Since we are only looking up to 150, it is easy to find all required primes using the same function as in my [Project Euler post]({% post_url 2019-09-18-project-euler %}):

```python
def is_prime(n):
	for i in range(2, int(math.sqrt(n)+1)):
		if n%i == 0:
			return False
	return True
```

Now, to find all primes of the form 4$k$+1, we use ```is_prime(n)``` to test numbers that are congruent to 1 modulo 4. Since 1 is not prime, we can start with 5 and check every fourth number for primality until we reach 150, using this function:

```python
def one_mod_four_primes(maximum):
	current = 5
	ans = []
	while current < maximum:
		if is_prime(current):
			ans.append(current)
		current = current + 4
	return ans
```

We have therefore completed part 1 of our overall goal. One way to solve the problem from here is to take the primes we have found and use them to generate squarefree numbers. That is, we want to find every combination generated by multiplying one or more of our primes, but never the same prime twice. An example using the first few primes is shown below, where the original primes are in blue and the numbers in black are the ones we want to return.
![Tree diagram](assets/images/posts/problem_273_tree.png)
To generate this list of numbers, let ```factors``` be our list of primes. Then we can use the function below to obtain our list:

```python
def squarefree_numbers(factors):
	if len(factors) == 0:
		return []
	first = factors[0]
	ans = [first]
	factors.pop(0)
	temp = squarefree_numbers(factors)
	ans.extend(temp)
	ans.extend([i*first for i in temp])
	return ans
```

We could then brute force our way through the problem of calculating $\sum S(N)$ for all numbers in our list. The problem is, our 16 prime factors lead to the creation of over 65,000 squarefree numbers, some of the order of $10^{18}$. Solving this by brute force is therefore going to take a long time. Luckily for us, there are existing mathematical theorems we can use to vastly improve the program's efficiency.

The first important thing to notice is that all of our prime factors are of the form $4k+1$. According to [Fermat's Theorem](http://mathworld.wolfram.com/Fermats4nPlus1Theorem.html), any prime number of this form can be written as the sum of two squares in exactly one way. As for the composite numbers, we can use a function called the [Sum of Squares Function](http://mathworld.wolfram.com/SumofSquaresFunction.html). To use this function, we first consider the prime factorisation of our target number $N$. In our case, we have:
<p style="text-align: center;">$N=p_1^{a_1}p_2^{a_2}...p_r^{a_r}$</p>
where each prime factor $p_1,p_2,...,p_r$ is of the form $4k+1$. Then, according to the Sum of Squares Function, the number of ways to write $N$ as a sum of 2 squares (ignoring order and signs) is equal to
<p style="text-align: center;">$\frac12(a_1+1)(a_2+1)...(a_r+1)$.</p>
Since we are only interested in squarefree numbers, the value of each index $a_1,a_2,...,a_r$ will either be 0 or 1. Hence, the number of ways of writing $N$ as a sum of two squares (again, ignoring order and signs) is equal to $2^{q-1}$, where $q$ is the number of distinct prime factors of $N$.

We now need to apply this to our Sum of Squares problem. Although it helps to know how many ways we should be able to write the sum for a given number, we want to find the sums themselves. For the prime factors we still can't do much better than brute force, but at least we know that we can return once we find one pair of integers whose squares add up to our desired target. For composite numbers, we need to find a way use the sums of prime factors to find the sums for their multiples. To construct the sums, we will use a generalised version of the approach described in [this forum](https://math.stackexchange.com/questions/1181336/the-number-of-ways-of-writing-an-integer-as-a-sum-of-two-squares). 

Consider our target $N$ as a product $pq$. Note that $p$ and $q$ are not necessarily prime. Suppose that we can write $p$ and $q$ as sums of squares in the following ways:
<p style="text-align: center;">
$$\begin{align}
p &= a^2+b^2 \\
q &= c^2+d^2
\end{align}$$
</p>
Then, we can write $N$ as follows:
<p style="text-align: center;">
$$\begin{align}
N &= pq \\
  &= (a^2+b^2)(c^2+d^2) \\
  &= (ac)^2+(ad)^2+(bc)^2+(bd)^2 \\
\end{align}$$
</p>

This can be continued in two possible ways (ignoring order and sign). First, we could write it as:
<p style="text-align: center;">
$$\begin{align}
N &= (ac)^2+(ad)^2+(bc)^2+(bd)^2 \\
  &= (ac)^2+2abcd+(bd)^2+(ad)^2-2abcd+(bc)^2 \\
  &= (ac+bd)^2+|ad-bc|^2
\end{align}$$
</p>
Alternatively, we could write it as:
<p style="text-align: center;">
$$\begin{align}
N &= (ac)^2+(ad)^2+(bc)^2+(bd)^2 \\
  &= (ad)^2+2abcd+(bc)^2+(ac)^2-2abcd+(bd)^2 \\
  &= (ad+bc)^2+|ac-bd|^2
\end{align}$$
</p>

Provided that $p\neq q$ and $p,q$ are both odd, these two representations will be distinct. Both conditions are met in our case, as $N$ is squarefree and is only divisible by odd numbers. Furthermore, in our case, if $p$ and $q$ can be represented as a sum of two squares in multiple different ways, each pair of representations $(a^2+b^2,c^2+d^2)$ will lead to two unique representations of $N$. Thus, by considering our target $N$ as a product of two numbers and recursively finding the sums for each factor, we can find all sums for $N$. For example, if our target was $1,105=5\times 221=5\times (13\times 17)$, we might determine how to write it as a sum of squares in the following way:
![Calculations](assets/images/posts/problem_273_calculations.png)
Notice that we are not interested in what the squarefree numbers are per se. Rather, we are interested in keeping track of the ways we can write them as the sum of two squares. To achieve this, we begin by writing a method to find the positive integers $a$ and $b$ such that $a< b $ and $a^2+b^2=N$ with $N$ prime. We do this by simply iterating through possible values of $a$ until we find one that works. Note that if $N\equiv 3\mod 4$, it cannot be written as the sum of two squares.

```python
def root_summands_of_prime(N):
	if N % 4 == 3:
		return 0
	if N == 2:
		return [1, 1]
	a = 0
	maximum = math.sqrt(N/2)
	while a <= maximum:
		a_squared = a**2
		b_squared = N - a_squared
		b = math.sqrt(b_squared)
		if b == round(math.sqrt(b_squared)):		
			return [a, int(b)]
		a = a + 1
```

Then, we can use the basic structure of our ```squarefree_numbers``` method, but modify it to return $a$ and $b$ values rather than the squarefree numbers $N$ that correspond to $a^2+b^2$. In addition, rather than taking a list of factors as a parameter, our method will expect a list whose elements are of the form $[a,b]$, where $a^2+b^2$ corresponds to a prime factor:

```python
def root_summands_of_composite(summands_list):
	if len(summands_list) == 0:
		return []
	first = summands_list[0]
	ans = [first]
	summands_list.pop(0)
	temp = root_summands_of_composite(summands_list)
	for t in temp:
		ans.append(t)
		ans.append([first[0]*t[0]+first[1]*t[1], abs(first[0]*t[1]-first[1]*t[0])])
		ans.append([first[0]*t[1]+first[1]*t[0], abs(first[0]*t[0]-first[1]*t[1])])
	return ans
```

Our overall solution will therefore involve finding the $a$ and $b$ values corresponding to each prime $p<150$ of the form $4k+1$, then using those to find the $a$ and $b$ values corresponding to composite squarefree numbers with prime factors of the form $4k+1$:

```python
def overall_solution(maximum):
	primes = one_mod_four_primes(maximum)
	summands_list = []
	for p in primes:
		summands_list.append(root_summands_of_prime(p))
	summands_list = root_summands_of_composite(summands_list)
	sum_s_of_n = add_mins(summands_list)
	return sum_s_of_n
```

Note that $S(N)$ only requires the values of $a$, so after we store the $a$ and $b$ values in ```summands_list``` we have utilised the function ```add_mins``` which is defined as follows:

```python
def add_mins(summands_list):
	total = 0
	for summands in summands_list:
		total += min(summands)
	return total
```

Our function now will complete the problem in a fraction of the time it would have taken to use brute force, thanks to the power of mathematics!